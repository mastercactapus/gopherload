package main

import (
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"sync/atomic"
	"time"

	"github.com/gorilla/mux"
	"github.com/mastercactapus/gopherload"
	log "github.com/sirupsen/logrus"
)

// LoadTest is a running load test
//
// swagger:model
type LoadTest struct {
	// ID is generated by the server to identify the load test.
	// read only: true
	ID string

	// URL is the fully-qualified URL to hit
	// required: true
	URL string

	// Method to use (e.g. GET, PUT, POST)
	Method string

	// Headers to send with each request
	Headers http.Header

	// Body to send with each request
	Body []byte

	// RPS is the number of requests to send per second. If negative, there is no limit.
	// default: -1
	RPS float64

	// RampUp is the RPS per second to ramp up to the defined RPS value. The rate is adjusted once per second until RPS is reached.
	// If zero, there will be no ramp-up period.
	RampUp float64

	// Concurrency is the maximum number of simultaneous requests. Defaults to 1. If negative, there will be no limit.
	Concurrency int

	// Limit is the number of requests to send. If negative, the test will continue until stopped.
	// default: -1
	Limit int

	// The current RPS (when ramping up)
	// read only: true
	CurrentRPS float64

	// The number of failed requests
	// read only: true
	Errors int

	// Completed requests
	// read only: true
	Completed int

	generator *gopherload.RequestGenerator
	throttle  *gopherload.Throttle
	load      *gopherload.LoadGenerator
	resCh     chan *gopherload.Result
}

func (l *LoadTest) Start() error {
	t := &gopherload.SimpleTemplate{
		Body:    l.Body,
		URL:     l.URL,
		Method:  l.Method,
		Headers: l.Headers,
	}

	l.generator = &gopherload.RequestGenerator{Source: t}
	if l.RampUp == 0 {
		l.throttle = gopherload.NewThrottle(l.generator.Start(), l.RPS)
	} else {
		l.throttle = gopherload.NewThrottle(l.generator.Start(), 0)
	}

	if l.Concurrency == 0 {
		l.Concurrency = 1
	}

	u, err := url.Parse(l.URL)
	if err != nil {
		return err
	}

	l.load = &gopherload.LoadGenerator{
		CLimit:   l.Concurrency,
		Source:   l.throttle.Output(),
		Profiler: gopherload.Target(u.Host),
	}
	resCh := make(chan *gopherload.Result, 8)
	l.load.Start(resCh)
	return nil
}

type testResult struct {
	ID     string
	Result *gopherload.Result
}
type resultsRequest struct {
	ID string
	ch chan []*gopherload.Result
}
type resultsListener struct {
	TestID string
	stop   chan struct{}
	ch     chan *gopherload.Result
}

type newTest struct {
	test LoadTest
	ch   chan string
}
type rateChange struct {
	ID         string
	TargetRate float64
}

type appState struct {
	tests     map[string]*LoadTest
	results   map[string][]*gopherload.Result
	listeners map[string]map[string]resultsListener
	resultsCh chan testResult

	listCh       chan chan []LoadTest
	addCh        chan newTest
	rateCh       chan rateChange
	stopCh       chan string
	getResultsCh chan resultsRequest
	resListenCh  chan resultsListener

	idNum int64
}

func NewAppState() *appState {
	state := &appState{
		tests:     make(map[string]*LoadTest, 20),
		results:   make(map[string][]*gopherload.Result),
		listeners: make(map[string]map[string]resultsListener, 20),
		resultsCh: make(chan testResult, 80),

		listCh:       make(chan chan []LoadTest, 10),
		addCh:        make(chan newTest, 10),
		rateCh:       make(chan rateChange),
		stopCh:       make(chan string),
		getResultsCh: make(chan resultsRequest),
		resListenCh:  make(chan resultsListener),
	}
	go state.loop()
	return state
}

func (state *appState) forwardResults(id string, ch chan *gopherload.Result) {
	var ok bool
	var res *gopherload.Result
	for {
		res, ok = <-ch
		if !ok {
			break
		}

		state.resultsCh <- testResult{ID: id, Result: res}
	}
}
func (state *appState) newID() string {
	return strconv.FormatInt(atomic.AddInt64(&state.idNum, 1), 64)
}

func (state *appState) loop() {
	t := time.NewTicker(time.Second)
	for {
		select {
		case <-t.C:
			// update RPS every second
			for _, test := range state.tests {
				if test.CurrentRPS == test.RPS {
					continue
				}
				if test.RampUp == 0 {
					test.CurrentRPS = test.RPS
				} else if test.CurrentRPS < test.RPS {
					test.CurrentRPS += test.RampUp
					if test.CurrentRPS > test.RPS {
						test.CurrentRPS = test.RPS
					}
				} else if test.CurrentRPS > test.RPS {
					test.CurrentRPS -= test.RPS
					if test.CurrentRPS < test.RPS {
						test.CurrentRPS = test.RPS
					}
				}
				test.throttle.SetRate(test.CurrentRPS)
			}
		case rCh := <-state.listCh:
			// process requests for test list
			result := make([]LoadTest, 0, len(state.tests))
			for _, t := range state.tests {
				result = append(result, *t)
			}
			rCh <- result
		case nt := <-state.addCh:
			// process requests to add tests
			nt.test.ID = state.newID()
			state.results[nt.test.ID] = make([]*gopherload.Result, 100000)
			state.tests[nt.test.ID] = &nt.test
			state.listeners[nt.test.ID] = make(map[string]resultsListener, 100)
			go state.forwardResults(nt.test.ID, nt.test.resCh)
			nt.ch <- nt.test.ID
		case rc := <-state.rateCh:
			// set new rps target
			if state.tests[rc.ID] != nil {
				state.tests[rc.ID].RPS = rc.TargetRate
			}
		case <-state.stopCh:
			// todo :)
		case gr := <-state.getResultsCh:
			// process requests for test results
			if state.results[gr.ID] == nil {
				gr.ch <- nil
				break
			}
			result := make([]*gopherload.Result, len(state.results[gr.ID]))
			copy(result, state.results[gr.ID])
			gr.ch <- result
		case lt := <-state.resListenCh:
			// add new listener
			state.listeners[lt.TestID][state.newID()] = resultsListener{ch: lt.ch, stop: lt.stop}
		case res := <-state.resultsCh:
			// append results
			state.results[res.ID] = append(state.results[res.ID], res.Result)
			for id, lt := range state.listeners[res.ID] {
				select {
				case <-lt.stop:
					delete(state.listeners[res.ID], id)
				default:
					lt.ch <- res.Result
				}
			}
		}
	}
}
func (state *appState) ListenResults(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")
	flusher := w.(http.Flusher)
	var l resultsListener

	l.TestID = mux.Vars(req)["TestID"]
	l.stop = make(chan struct{})
	defer close(l.stop)
	l.ch = make(chan *gopherload.Result, 10)

	state.resListenCh <- l

	var buf []byte
	var err error
	for res := range l.ch {
		buf, err = json.Marshal(res)
		if err != nil {
			log.Errorln(err)
			return
		}
		_, err = io.WriteString(w, "data: "+string(buf)+"\n\n")
		if err != nil {
			return
		}
		flusher.Flush()
	}
}
func (state *appState) GetResults(w http.ResponseWriter, req *http.Request) {
	ch := make(chan []*gopherload.Result, 1)
	state.getResultsCh <- resultsRequest{ID: mux.Vars(req)["TestID"], ch: ch}
	res := <-ch
	w.Header().Set("content-type", "application/json")
	err := json.NewEncoder(w).Encode(res)
	if err != nil {
		if err != nil {
			http.Error(w, err.Error(), 500)
			log.Warnln(err)
		}
	}
}
func (state *appState) GetLoadTests(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("content-type", "application/json")
	ch := make(chan []LoadTest, 1)
	state.listCh <- ch
	err := json.NewEncoder(w).Encode(<-ch)
	if err != nil {
		http.Error(w, err.Error(), 500)
		log.Warnln(err)
	}
}
func (state *appState) CreateLoadTest(w http.ResponseWriter, req *http.Request) {
	var n *LoadTest
	err := json.NewDecoder(req.Body).Decode(n)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	err = n.Start()
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	ch := make(chan string, 1)
	state.addCh <- newTest{test: *n, ch: ch}
	n.ID = <-ch

	log.WithField("URL", n.URL).Infoln("started new load test")
	w.Header().Set("content-type", "application/json")
	err = json.NewEncoder(w).Encode(n)
	if err != nil {
		http.Error(w, err.Error(), 500)
	}
}

func Serve(addr string) {
	state := NewAppState()
	r := mux.NewRouter()
	r.Path("/load-tests/{TestID}/results").Methods("GET").HandlerFunc(state.GetResults)
	r.Path("/load-tests/{TestID}/result-stream").Methods("GET").HandlerFunc(state.ListenResults)
	r.Path("/load-tests").Methods("GET").HandlerFunc(state.GetLoadTests)
	r.Path("/load-tests").Methods("POST").HandlerFunc(state.CreateLoadTest)

	log.Fatalln(http.ListenAndServe(addr, requestLogger(r)))
}
